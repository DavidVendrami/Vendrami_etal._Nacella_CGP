// Model H_4_1:1
initialize() {
	//setSeed(seed);
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(keepPedigrees=T);
	defineConstant("K", 1000);	// carrying capacity
	defineConstant("St", 10);	// Stack size
	defineConstant("Wb1", 0.4);	// parameter 1 for rweibull
	defineConstant("Wb2", 0.22);	// parameter 2 for rweibull
	
	// neutral mutations, which are allowed to fix
	initializeMutationType("m1", 0.5, "f", 0.0);
	m1.convertToSubstitution = T;
	
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, 99999);
	initializeMutationRate(1e-7);
	initializeRecombinationRate(1e-8);
}

// Reproduction: stack-SFS reproduction
// Severity of SFS depending on the third parameter of rweibull()
// 0.55 = very weak (very very max ~ 20)
// 0.25 = very strong (max can be > 500 => a whole pop generated by one stack).
1:5 reproduction() {
	for (subpopA in sim.subpopulations){
		check = 0;
		everyb = subpopA.individuals;
		rind = sample(everyb,length(everyb),replace=F);
		
		while (check < K){
			if (length(rind) >= 40){
				parents = rind[0:19];
				rind = rind[20:(length(rind)-1)];
				for (z in 1:100){
					parent1 = sample(parents[0:9],1);
					parent2 = sample(parents[10:19],1);
					if (parent2 != parent1){
						litter = asInteger(rweibull(1,0.4,0.55));
						check = check + litter;
						for (j in 1:litter){
							subpopA.addCrossed(parent1, parent2);
						}}
				}} else {
				parent1 = sample(rind[0:9],1);
				parent2 = sample(rind[10:19],1);
				if (parent2 != parent1){
					litter = asInteger(rweibull(1,0.4,0.55));
					check = check + litter;
					for (w in 1:litter){
						subpopA.addCrossed(parent1, parent2);
					}}}
		}}
	
	// disable this callback for this generation
	self.active = 0;
}

6 reproduction() {
	for (subpopA in sim.subpopulations[c(0,1,2,3)]){
		check = 0;
		everyb = subpopA.individuals;
		rind = sample(everyb,length(everyb),replace=F);
		
		while (check < K){
			if (length(rind) >= 40){
				parents = rind[0:19];
				rind = rind[20:(length(rind)-1)];
				for (z in 1:100){
					parent1 = sample(parents[0:9],1);
					parent2 = sample(parents[10:19],1);
					if (parent2 != parent1){
						litter = asInteger(rweibull(1,0.4,0.55));
						check = check + litter;
						for (j in 1:litter){
							subpopA.addCrossed(parent1, parent2);
						}}
				}} else {
				parent1 = sample(rind[0:9],1);
				parent2 = sample(rind[10:19],1);
				if (parent2 != parent1){
					litter = asInteger(rweibull(1,0.4,0.55));
					check = check + litter;
					for (w in 1:litter){
						subpopA.addCrossed(parent1, parent2);
					}}}
		}}
	
	
	// Here is where you change stuff
	check = 0;
	everyb = p5.individuals;
	rind = sample(everyb,length(everyb),replace=F);
	stack1 = rind[0:(St-1)];
	stack2 = rind[St:(St*2-1)];
	stack3 = rind[(St*2):(St*3-1)];
	stack4 = rind[(St*3):(St*4-1)];
	stack5 = rind[(St*4):(St*5-1)];
	stack6 = rind[(St*5):(St*6-1)];
	stack7 = rind[(St*6):(St*7-1)];
	stack8 = rind[(St*7):(St*8-1)];
	
	
	while (check < K){
					parents11 = sample(stack1[0:1],1);
					parents12 = sample(stack1[(asInteger(St/2)):(St-1)],1);
					parents21 = sample(stack2[0:1],1);
					parents22 = sample(stack2[(asInteger(St/2)):(St-1)],1);
					parents31 = sample(stack3[0:1],1);
					parents32 = sample(stack3[(asInteger(St/2)):(St-1)],1);
					parents41 = sample(stack4[0:1],1);
					parents42 = sample(stack4[(asInteger(St/2)):(St-1)],1);
					parents51 = sample(stack5[0:1],1);
					parents52 = sample(stack5[(asInteger(St/2)):(St-1)],1);
					parents61 = sample(stack6[0:1],1);
					parents62 = sample(stack6[(asInteger(St/2)):(St-1)],1);
					parents71 = sample(stack7[0:1],1);
					parents72 = sample(stack7[(asInteger(St/2)):(St-1)],1);
					parents81 = sample(stack8[0:1],1);
					parents82 = sample(stack8[(asInteger(St/2)):(St-1)],1);
					
					
						litters1 = asInteger(rweibull(1,Wb1,Wb2));
						if (litters1<125){
						litters2 = asInteger(rweibull(1,Wb1,Wb2));
						if (litters2<125){
						litters3 = asInteger(rweibull(1,Wb1,Wb2));
						if (litters3<125){
						litters4 = asInteger(rweibull(1,Wb1,Wb2));
						if (litters4<125){
						litters5 = asInteger(rweibull(1,Wb1,Wb2));
						if (litters5<125){
						litters6 = asInteger(rweibull(1,Wb1,Wb2));
						if (litters6<125){
						litters7 = asInteger(rweibull(1,Wb1,Wb2));
						if (litters7<125){
						litters8 = asInteger(rweibull(1,Wb1,Wb2));
						if (litters8<125){
						
						
						check = check + litters1 + litters2 + litters3 + litters4 + litters5 + litters6 + litters7 + litters8;
						
						for (j in 1:litters1){
							p5.addCrossed(parents11, parents12);
						
				} 
				      for (j in 1:litters2){
				      p5.addCrossed(parents21, parents22);
				      }
				      for (j in 1:litters3){
							p5.addCrossed(parents31, parents32);
						
				}
				for (j in 1:litters4){
							p5.addCrossed(parents41, parents42);
						
				}
				for (j in 1:litters5){
							p5.addCrossed(parents51, parents52);
						
				}
				for (j in 1:litters6){
							p5.addCrossed(parents61, parents62);
						
				}
				for (j in 1:litters7){
							p5.addCrossed(parents71, parents72);
						
				}
				for (j in 1:litters8){
							p5.addCrossed(parents81, parents82);
						
				}}}}}}}}}
				
		}
	
	// disable this callback for this generation
	self.active = 0;
}
// create an initial population of 500 individuals
1 early() {
	sim.addSubpop("p1", 500);
	sim.addSubpop("p2", 500);
	sim.addSubpop("p3", 500);
	sim.addSubpop("p4", 500);
	sim.addSubpop("p5", 500);

}
// provide density-dependent selection with non-overlapping generations
early() {
	for (subpopB in sim.subpopulations){
		inds = subpopB.individuals;
		inds.fitnessScaling = ifelse(inds.age == 0, 1.0, 0.0);
		subpopB.fitnessScaling = K / sum(inds.fitnessScaling);
	}}

// Check samples of relatedness
6 late() {
// This checks relat in all pops
//	for (subpopC in sim.subpopulations){
//		samrel = subpopC.sampleIndividuals(10);
//		catn("0: " + length(which(samrel.relatedness(samrel)==0)) + ", 0.25: " + length(which(samrel.relatedness(samrel)==0.25)) + ", 0.5: " + //length(which(samrel.relatedness(samrel)==0.5)));
//	}


// This checks it only in p5	
		samrel = p5.sampleIndividuals(10);
		catn("0: " + length(which(samrel.relatedness(samrel)==0)) + ", 0.25: " + length(which(samrel.relatedness(samrel)==0.25)) + ", 0.5: " + length(which(samrel.relatedness(samrel)==0.5)));
	

	
	
	
	total = 0.0;
	for (ind in p1.individuals)
	{
		// Calculate the nucleotide heterozygosity of this individual
		muts0 = ind.genomes[0].mutations;
		muts1 = ind.genomes[1].mutations;
		// Count the shared mutations
		shared_count = sum(match(muts0, muts1) >= 0);
		// All remaining mutations are unshared (i.e. heterozygous)
		unshared_count = muts0.size() + muts1.size() - 2 * shared_count;
		// pi is the mean heterozygosity across the chromosome
		pi_ind = unshared_count / (sim.chromosome.lastPosition + 1);
		total = total + pi_ind;
	}
	pi = total / p1.individuals.size();
	cat("Mean nucleotide heterozygosity pop1 = " + pi + "\n");
	
	total = 0.0;
	for (ind in p2.individuals)
	{
		// Calculate the nucleotide heterozygosity of this individual
		muts0 = ind.genomes[0].mutations;
		muts1 = ind.genomes[1].mutations;
		// Count the shared mutations
		shared_count = sum(match(muts0, muts1) >= 0);
		// All remaining mutations are unshared (i.e. heterozygous)
		unshared_count = muts0.size() + muts1.size() - 2 * shared_count;
		// pi is the mean heterozygosity across the chromosome
		pi_ind = unshared_count / (sim.chromosome.lastPosition + 1);
		total = total + pi_ind;
	}
	pi = total / p2.individuals.size();
	cat("Mean nucleotide heterozygosity pop1 = " + pi + "\n");
	
	total = 0.0;
	for (ind in p3.individuals)
	{
		// Calculate the nucleotide heterozygosity of this individual
		muts0 = ind.genomes[0].mutations;
		muts1 = ind.genomes[1].mutations;
		// Count the shared mutations
		shared_count = sum(match(muts0, muts1) >= 0);
		// All remaining mutations are unshared (i.e. heterozygous)
		unshared_count = muts0.size() + muts1.size() - 2 * shared_count;
		// pi is the mean heterozygosity across the chromosome
		pi_ind = unshared_count / (sim.chromosome.lastPosition + 1);
		total = total + pi_ind;
	}
	pi = total / p3.individuals.size();
	cat("Mean nucleotide heterozygosity pop1 = " + pi + "\n");
	
	total = 0.0;
	for (ind in p4.individuals)
	{
		// Calculate the nucleotide heterozygosity of this individual
		muts0 = ind.genomes[0].mutations;
		muts1 = ind.genomes[1].mutations;
		// Count the shared mutations
		shared_count = sum(match(muts0, muts1) >= 0);
		// All remaining mutations are unshared (i.e. heterozygous)
		unshared_count = muts0.size() + muts1.size() - 2 * shared_count;
		// pi is the mean heterozygosity across the chromosome
		pi_ind = unshared_count / (sim.chromosome.lastPosition + 1);
		total = total + pi_ind;
	}
	pi = total / p4.individuals.size();
	cat("Mean nucleotide heterozygosity pop1 = " + pi + "\n");
	
	total = 0.0;
	for (ind in p5.individuals)
	{
		// Calculate the nucleotide heterozygosity of this individual
		muts0 = ind.genomes[0].mutations;
		muts1 = ind.genomes[1].mutations;
		// Count the shared mutations
		shared_count = sum(match(muts0, muts1) >= 0);
		// All remaining mutations are unshared (i.e. heterozygous)
		unshared_count = muts0.size() + muts1.size() - 2 * shared_count;
		// pi is the mean heterozygosity across the chromosome
		pi_ind = unshared_count / (sim.chromosome.lastPosition + 1);
		total = total + pi_ind;
	}
	pi = total / p5.individuals.size();
	cat("Mean nucleotide heterozygosity pop5 = " + pi + "\n");
}

//late() {
//	inds = p1.individuals;
//	catn(min(inds.age) + " (" + max(inds.age) + ", " + mean(inds.age) + ")");
//}


// output all fixed mutations at end
6 late() { sim.outputFixedMutations();
}

