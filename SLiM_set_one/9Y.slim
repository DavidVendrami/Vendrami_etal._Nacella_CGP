// Model H_4_1:1
initialize() {
	//setSeed(seed);
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(keepPedigrees=T);
	defineConstant("K", 1000);	// carrying capacity
	defineConstant("St", 10);	// Stack size
	defineConstant("Wb1", 0.4);	// parameter 1 for rweibull
	defineConstant("Wb2", 0.22);	// parameter 2 for rweibull
	
	// neutral mutations, which are allowed to fix
	initializeMutationType("m1", 0.5, "f", 0.0);
	m1.convertToSubstitution = T;
	
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, 99999);
	initializeMutationRate(1e-7);
	initializeRecombinationRate(1e-8);
}

// Reproduction: stack-SFS reproduction
// Severity of SFS depending on the third parameter of rweibull()
// 0.55 = very weak (very very max ~ 20)
// 0.25 = very strong (max can be > 500 => a whole pop generated by one stack).
1:5 reproduction() {
	for (subpopA in sim.subpopulations){
		check = 0;
		everyb = subpopA.individuals;
		rind = sample(everyb,length(everyb),replace=F);
		
		while (check < K){
			if (length(rind) >= 40){
				parents = rind[0:19];
				rind = rind[20:(length(rind)-1)];
				for (z in 1:100){
					parent1 = sample(parents[0:9],1);
					parent2 = sample(parents[10:19],1);
					if (parent2 != parent1){
						litter = asInteger(rweibull(1,0.4,0.55));
						check = check + litter;
						for (j in 1:litter){
							subpopA.addCrossed(parent1, parent2);
						}}
				}} else {
				parent1 = sample(rind[0:9],1);
				parent2 = sample(rind[10:19],1);
				if (parent2 != parent1){
					litter = asInteger(rweibull(1,0.4,0.55));
					check = check + litter;
					for (w in 1:litter){
						subpopA.addCrossed(parent1, parent2);
					}}}
		}}
	
	// disable this callback for this generation
	self.active = 0;
}

6 reproduction() {
	for (subpopA in sim.subpopulations[c(0,1,2,3)]){
		check = 0;
		everyb = subpopA.individuals;
		rind = sample(everyb,length(everyb),replace=F);
		
		while (check < K){
			if (length(rind) >= 40){
				parents = rind[0:19];
				rind = rind[20:(length(rind)-1)];
				for (z in 1:100){
					parent1 = sample(parents[0:9],1);
					parent2 = sample(parents[10:19],1);
					if (parent2 != parent1){
						litter = asInteger(rweibull(1,0.4,0.55));
						check = check + litter;
						for (j in 1:litter){
							subpopA.addCrossed(parent1, parent2);
						}}
				}} else {
				parent1 = sample(rind[0:9],1);
				parent2 = sample(rind[10:19],1);
				if (parent2 != parent1){
					litter = asInteger(rweibull(1,0.4,0.55));
					check = check + litter;
					for (w in 1:litter){
						subpopA.addCrossed(parent1, parent2);
					}}}
		}}
	
	
	// Here is where you change stuff
	check = 0;
	everyb = p5.individuals;
	rind = sample(everyb,length(everyb),replace=F);
	
	while (check < K){
				parents = rind[0:(St-1)];
					parent1 = sample(parents[0:8],1);
					parent2 = sample(parents[(asInteger(St/2)):(St-1)],1);
						litter = asInteger(rweibull(1,Wb1,Wb2));
						if (litter<111){
						check = check + litter;
						for (j in 1:litter){
							p5.addCrossed(parent1, parent2);
						
				}}
		}
	
	// disable this callback for this generation
	self.active = 0;
}
// create an initial population of 500 individuals
1 early() {
	sim.addSubpop("p1", 500);
	sim.addSubpop("p2", 500);
	sim.addSubpop("p3", 500);
	sim.addSubpop("p4", 500);
	sim.addSubpop("p5", 500);

}
// provide density-dependent selection with non-overlapping generations
early() {
	for (subpopB in sim.subpopulations){
		inds = subpopB.individuals;
		inds.fitnessScaling = ifelse(inds.age == 0, 1.0, 0.0);
		subpopB.fitnessScaling = K / sum(inds.fitnessScaling);
	}}

// Check samples of relatedness
6 late() {
// This checks relat in all pops
//	for (subpopC in sim.subpopulations){
//		samrel = subpopC.sampleIndividuals(10);
//		catn("0: " + length(which(samrel.relatedness(samrel)==0)) + ", 0.25: " + length(which(samrel.relatedness(samrel)==0.25)) + ", 0.5: " + //length(which(samrel.relatedness(samrel)==0.5)));
//	}


// This checks it only in p5	
		samrel = p5.sampleIndividuals(10);
		catn("0: " + length(which(samrel.relatedness(samrel)==0)) + ", 0.25: " + length(which(samrel.relatedness(samrel)==0.25)) + ", 0.5: " + length(which(samrel.relatedness(samrel)==0.5)));
	

	
	
	
	total = 0.0;
	for (ind in p1.individuals)
	{
		// Calculate the nucleotide heterozygosity of this individual
		muts0 = ind.genomes[0].mutations;
		muts1 = ind.genomes[1].mutations;
		// Count the shared mutations
		shared_count = sum(match(muts0, muts1) >= 0);
		// All remaining mutations are unshared (i.e. heterozygous)
		unshared_count = muts0.size() + muts1.size() - 2 * shared_count;
		// pi is the mean heterozygosity across the chromosome
		pi_ind = unshared_count / (sim.chromosome.lastPosition + 1);
		total = total + pi_ind;
	}
	pi = total / p1.individuals.size();
	cat("Mean nucleotide heterozygosity pop1 = " + pi + "\n");
	
	total = 0.0;
	for (ind in p2.individuals)
	{
		// Calculate the nucleotide heterozygosity of this individual
		muts0 = ind.genomes[0].mutations;
		muts1 = ind.genomes[1].mutations;
		// Count the shared mutations
		shared_count = sum(match(muts0, muts1) >= 0);
		// All remaining mutations are unshared (i.e. heterozygous)
		unshared_count = muts0.size() + muts1.size() - 2 * shared_count;
		// pi is the mean heterozygosity across the chromosome
		pi_ind = unshared_count / (sim.chromosome.lastPosition + 1);
		total = total + pi_ind;
	}
	pi = total / p2.individuals.size();
	cat("Mean nucleotide heterozygosity pop1 = " + pi + "\n");
	
	total = 0.0;
	for (ind in p3.individuals)
	{
		// Calculate the nucleotide heterozygosity of this individual
		muts0 = ind.genomes[0].mutations;
		muts1 = ind.genomes[1].mutations;
		// Count the shared mutations
		shared_count = sum(match(muts0, muts1) >= 0);
		// All remaining mutations are unshared (i.e. heterozygous)
		unshared_count = muts0.size() + muts1.size() - 2 * shared_count;
		// pi is the mean heterozygosity across the chromosome
		pi_ind = unshared_count / (sim.chromosome.lastPosition + 1);
		total = total + pi_ind;
	}
	pi = total / p3.individuals.size();
	cat("Mean nucleotide heterozygosity pop1 = " + pi + "\n");
	
	total = 0.0;
	for (ind in p4.individuals)
	{
		// Calculate the nucleotide heterozygosity of this individual
		muts0 = ind.genomes[0].mutations;
		muts1 = ind.genomes[1].mutations;
		// Count the shared mutations
		shared_count = sum(match(muts0, muts1) >= 0);
		// All remaining mutations are unshared (i.e. heterozygous)
		unshared_count = muts0.size() + muts1.size() - 2 * shared_count;
		// pi is the mean heterozygosity across the chromosome
		pi_ind = unshared_count / (sim.chromosome.lastPosition + 1);
		total = total + pi_ind;
	}
	pi = total / p4.individuals.size();
	cat("Mean nucleotide heterozygosity pop1 = " + pi + "\n");
	
	total = 0.0;
	for (ind in p5.individuals)
	{
		// Calculate the nucleotide heterozygosity of this individual
		muts0 = ind.genomes[0].mutations;
		muts1 = ind.genomes[1].mutations;
		// Count the shared mutations
		shared_count = sum(match(muts0, muts1) >= 0);
		// All remaining mutations are unshared (i.e. heterozygous)
		unshared_count = muts0.size() + muts1.size() - 2 * shared_count;
		// pi is the mean heterozygosity across the chromosome
		pi_ind = unshared_count / (sim.chromosome.lastPosition + 1);
		total = total + pi_ind;
	}
	pi = total / p5.individuals.size();
	cat("Mean nucleotide heterozygosity pop5 = " + pi + "\n");
}

//late() {
//	inds = p1.individuals;
//	catn(min(inds.age) + " (" + max(inds.age) + ", " + mean(inds.age) + ")");
//}


// output all fixed mutations at end
6 late() { sim.outputFixedMutations();
}

